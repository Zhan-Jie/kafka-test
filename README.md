## 1. 分布式 ##

kafka以集群方式运行，包含一个或多个broker（或者说是kafka server） 。

## 2. Topic ##

kafka将消息以topic为分组进行归纳。

生产者发送消息时应该指定topic，消费者接收消息时也应该指定消息的topic。

### 2.1 topic、分区与消息 ###

kafka将每个topic的消息分为一个或多个分区，每个分区存储了一系列顺序编号(`offset`)的、不可改变的记录（`Record`）。

记录可以设置生存时间，在这个时间内记录一直存在。消费者自己保存记录的编号，通过指定编号来访问分区内的消息。

![topic partitions](http://kafka.apache.org/10/images/log_anatomy.png)

每个消息分区对应kafka broker上的一个目录。比如名为为`test`的topic有两个分区，那么就对应`test-0`、`test-1`两个目录。分区的消息不断追加到对应目录的日志文件中。

### 2.2 topic分区副本 ###

关于topic分区有以下性质：

- 一个分区在不同的broker上存在副本，副本数(replication factor)由客户端创建时指定。
- 在一个分区的所有副本里，有一个副本作为主分区（leader），其它副本称为副本分区（follower）。
- 主分区才会处理对该分区的读写请求，其它次要分区只复制与它保持一致。
- 当主分区所在broker崩溃，其它的副本分区就会选举一个作为主分区。

### 2.3 消息的格式 ###

kafka的消息存储格式在不同版本中具体格式不同。但是消息总体可以分为消息头、键、值。其中键和值都是字节数组形式，即可以是任意二进制数据。

参考：http://kafka.apache.org/documentation/#messages

## 3. 消费者 ##

### 3.1 消费者组 ###

每个消费者属于一个消费者组(Consumer Group)，不同的消费者组读取同一个topic下的消息互不影响，每条消息在消费者组之间是共享的。而同一个消费者组内的消费者是竞争消息的，即一条消息只被消费者组内的一个消费者消费。

### 3.2 消息顺序保证 ###

每个topic下分区内的消息都是按照发送顺序存储，每个消息都能够按照顺序被消费者消费。

因为一个消费者组内一次只有一个消费者能得到消息，多个消费者组都能按顺序接收到整个分区所有消息。所以一个分区内的消息是按顺序被消费的。

传统的队列系统，所有消费者是竞争队列的消息，当消息是异步发送，可能会被消费者乱序接收到。（这在RabbitMQ应该不存在，因为它有消费者消息确认机制）。

## 4. 生产者 ##

### 4.1 请求的负载均衡 ###

生产者是直接发送数据到topic的leader分区所在服务器，中间不需要任何路由转发（看向RabbitMQ）。

Kafka集群所有节点（broker）都可以响应生产者的请求，如果请求的leader分区不在当前节点，那么它将告诉消费者正确的节点地址，消费者就可以重定向过去。